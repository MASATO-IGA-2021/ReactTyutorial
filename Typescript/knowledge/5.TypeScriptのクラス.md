# 5.TypeScript のクラス

## 5-1 クラスの宣言と使用

- クラス宣言と new 構文
  `class クラス名 {~~}`: クラス宣言
  `new クラス名()`: インスタンス化
- プロパティを宣言する
  `プロパティ名: 型 = 式;`
  - `プロパティ名: 型`という形で宣言することも可能だが、**コンストラクタと併用しなければいけない**
  - 読み取り専用やオプショナルとすることも可能
- メソッドを宣言する
  - オブジェクトリテラルのメソッド記法と同様の書き方
- コンストラクタ
  - **コンストラクタ**：new よりインスタンスが作成される際に呼び出される関数
    `constructor(引数: 型,...) {~~}`
  - コンストラクタ内ですべてのプロパティに値を代入しなければいけない。
  - 読み取り専用のプロパティに代入することができる
- 静的プロパティ・静的メソッド
  - **静的**:クラスそのものに属する。
    `static`を用いて宣言する
  ```

  ```
  - インスタンスから静的プロパティを取得することはできない
- 3 種類のアクセシビリティ修飾子
  - クラス内のプロパティ・メソッドに対して`public` `protected` `private`を付与することができる
  - public: どこからでもアクセス可能
  - private: そのクラス内でしかアクセスすることができない
  - protected: そのクラス内とそのクラスを継承したクラスのみしかアクセスすることができない
- コンストラクタ引数でのプロパティ宣言
  - 受け取った引数をそのままプロパティの初期化に利用する
  - 以下のソースコードは同義
  ```
  class User {
    public name: string;
    private age: number;
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
  }
  ```
  ```
  class User{
    constructor(public name: string, private age: number){}
  }
  ```
  - 引数に`public`, `private`を付けることでコンストラクタでプロパティ宣言と理解し、同名のプロパティとして代入する
- クラス式でクラスを作成する
  `const クラス名 = class {~~}`より動的にクラスを生成することができる
- もう一つのプライベートプロパティ
  - `#プロパティ名`のように `#`を付与するだけでそのクラス内部のみアクセス可能となる
  - アクセスするとき、`this.#プロパティ名`
  - `private`は、TypeScript 由来。`#`は Javascript 由来であるため`#`はコンパイル後もアクセスを制限したソースコードになるが、`private`ではコンパイル後は public と同じソースコードになる
- クラスの静的初期化ブロック
  `static {~~}`:クラス宣言の評価の最中で実行されるブロック
  - static ブロックを使うことで**クラス宣言の一部**として書くことができ、クラス宣言の一部であるからこそ、プライベートプロパティへのアクセスを通じた特権的な処理を実現できる
- 型引数を持つクラス
  ```
  class User<T> {
    name: string;
    #age: number;
    data: T;
    constructor(name: string, age: number, data: T) {
        this.name = name;
        this.#age = age;
        this.data = data;
    }
  }
  ```

## 5-2 クラスの型

- クラス宣言はインスタンスの型を作る

  - クラス宣言の特徴の 1 つは、**クラスオブジェクトという値を作るものであると同時に、インスタンスの型を宣言するもの**である

  ```
  class User {
    name: string = '';
    age: number  = 0;
    isAdult(): boolean {
        return this.age >= 20;
    }
  }

  const john: User = {
    name: 'john';
    age: 15;
    isAdult:() => true;
  }
  ```

  - 構造的部分型付けより上記のソースコードは User 型として扱われる
  - クラス式では上記のソースコードは User 型として扱われず、エラーとなる

- new シグネチャによるウインスタンス化可能性を表現
- instanceof 演算子と型の絞り込み
  `値 instanceof クラスオブジェクト`:真偽値を返す
  - クラス型に適合するオブジェクトの場合、true を返すわけではなく、クラスのインスタンスである場合 true が返される
  - つまり ○○ 型のオブジェクトであることと ○○ クラスのインスタンスであることは全く同じ意味ではない
  - ○○ 型であるならば ○○ クラスのインスタンス：誤。○○ クラスのインスタンスならば ○○ 型：真
  - クラスはあくまでもオブジェクト型を宣言し、その型のオブジェクトを宣言するための便利な方法を提供する仕組み

## 5-3 クラスの継承
- 継承(1)子は親の機能を受け継ぐ
  `class クラス名 extends 親クラス {~~}`クラス式の場合はクラス名を省略し`class  extends 親クラス {~~}`という形になる
- 継承(2)親の機能を上書きする
  - 子クラスは親機能を上書き(オーバーライド)することができる
  - オーバーライドを適用するには、子クラスのインスタンスは親クラスのインスタンスの部分型である必要がある
  - 子クラス側でメソッドの引数の型や返り値の型を変更するとはできない
  - 子クラス内で親クラスのコンストラクタを呼び出すには`super`を用いる
- override修飾子とその威力
  - `override`修飾子を付けることでオーバーライドしていることを明示することができる。ただ、明示しなくても問題はない。
  - tsconfig.jsonファイル内の`noImplicitOverride`コンパイラオプションを有効にすることで、オーバーライドする時は明示しなければエラーが発生する
  
## 5-4 this

## 5-5 例外処理
